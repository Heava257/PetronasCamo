const {
  db,
  isArray,
  isEmpty,
  logError,
  removeFile,
} = require("../util/helper");

exports.getList = async (req, res) => {
  try {
    const { txt_search, category_id, page, is_list_all } = req.query;
    const { user_id } = req.params;

    const pageSize = 10;
    const currentPage = Number(page) || 1;
    const offset = (currentPage - 1) * pageSize;

    // ✅ Added customer_id to SELECT
    const sqlSelect = `
      SELECT 
        p.id, p.name, p.category_id, p.barcode, p.company_name,
        p.description, p.qty, p.unit_price, p.discount, p.actual_price, p.status,
        p.create_by, p.create_at, p.unit, p.customer_id,
        c.name AS category_name,
        c.barcode AS category_barcode,
        cu.name AS customer_name,     -- ✅ ADD HERE!
        cu.address AS customer_address,
        cu.tel AS customer_tel,
        c.actual_price AS category_actual_price,
        (p.qty * p.unit_price) AS original_price,
        CASE
          WHEN p.discount > 0 THEN ((p.qty * p.unit_price) * (1 - p.discount / 100)) / c.actual_price
          ELSE (p.qty * p.unit_price) / c.actual_price
        END AS total_price
    `;

    const sqlJoin = `
  FROM product p
  LEFT JOIN category c ON p.category_id = c.id
  LEFT JOIN customer cu ON p.customer_id = cu.id     -- ✅ ADD JOIN TO CUSTOMER
`;

    let sqlWhere = `WHERE p.user_id = :user_id AND p.qty > 0`;



    if (txt_search) {
      sqlWhere += ` AND (p.name LIKE :txt_search OR p.barcode = :barcode)`;
    }
    if (category_id) {
      sqlWhere += ` AND p.category_id = :category_id`;
    }

    const sqlOrderBy = `ORDER BY p.customer_id, p.id DESC`;


    const sqlParam = {
      user_id,
      txt_search: `%${txt_search || ''}%`,
      barcode: txt_search || '',
      category_id,
    };

    const [list] = await db.query(sqlList, sqlParam);

    let total = 0;
    if (currentPage === 1) {
      const sqlTotal = `SELECT COUNT(p.id) AS total ${sqlJoin} ${sqlWhere}`;
      const [count] = await db.query(sqlTotal, sqlParam);
      total = count[0]?.total || 0;
    }

    return res.json({
      list,
      total,
    });
  } catch (error) {
    console.error("❌ Error in product.getList:", error);
    return res.status(500).json({ error: "Internal server error" });
  }
};


exports.getCustomerProducts = async (req, res) => {
  try {
    const { customer_id } = req.params;
    const { user_id } = req.query;

    if (!customer_id) {
      return res.status(400).json({
        error: true,
        message: "Customer ID is required"
      });
    }

    // First, verify customer exists and user has access (with group filtering)
    const sqlCustomerCheck = `
      SELECT c.id, c.name, c.tel, c.address, c.email, c.create_at, c.user_id
      FROM customer c
      INNER JOIN user u ON c.user_id = u.id
      INNER JOIN user cu ON cu.group_id = u.group_id
      WHERE c.id = ? AND cu.id = ?
      ${user_id ? 'AND c.user_id = ?' : ''}
      LIMIT 1
    `;

    const customerCheckParams = user_id ? [customer_id, req.current_id, user_id] : [customer_id, req.current_id];
    const [customerInfo] = await db.query(sqlCustomerCheck, customerCheckParams);

    if (!customerInfo || customerInfo.length === 0) {
      return res.status(404).json({
        error: true,
        message: "Customer not found or access denied"
      });
    }

    // Fixed SQL for customer products grouped by category (with group filtering)
    const sqlCustomerProducts = `
      SELECT 
        p.customer_id,
        c.id as category_id,
        c.name as category_name,
        c.barcode as category_barcode,
        SUM(CAST(p.qty AS DECIMAL(10,2))) as total_quantity,
        COUNT(p.id) as product_count,
        SUM(
          CASE
            WHEN p.discount > 0 AND p.discount IS NOT NULL 
            THEN CAST(p.qty AS DECIMAL(10,2)) * CAST(p.unit_price AS DECIMAL(10,2)) * (1 - CAST(p.discount AS DECIMAL(5,2)) / 100)
            ELSE CAST(p.qty AS DECIMAL(10,2)) * CAST(p.unit_price AS DECIMAL(10,2))
          END
        ) AS total_value,
        AVG(CAST(p.unit_price AS DECIMAL(10,2))) as avg_unit_price,
        GROUP_CONCAT(DISTINCT COALESCE(p.company_name, 'Unknown') SEPARATOR ', ') as companies,
        MIN(p.create_at) as first_purchase,
        MAX(p.create_at) as last_purchase
      FROM product p
      LEFT JOIN category c ON p.category_id = c.id
      INNER JOIN user u ON p.user_id = u.id
      INNER JOIN user cu ON cu.group_id = u.group_id
      WHERE p.customer_id = ? AND cu.id = ?
      ${user_id ? 'AND p.user_id = ?' : ''}
      AND p.status != 'deleted'
      GROUP BY p.customer_id, c.id, c.name, c.barcode
      HAVING total_quantity > 0
      ORDER BY total_value DESC, total_quantity DESC
    `;

    // Fixed SQL for detailed products (with group filtering)
    const sqlDetailedProducts = `
      SELECT 
        p.id, 
        p.name, 
        p.category_id, 
        p.barcode, 
        COALESCE(p.company_name, 'Unknown') as company_name,
        p.description, 
        CAST(p.qty AS DECIMAL(10,2)) as qty, 
        CAST(p.unit_price AS DECIMAL(10,2)) as unit_price, 
        CAST(COALESCE(p.discount, 0) AS DECIMAL(5,2)) as discount, 
        CAST(p.actual_price AS DECIMAL(10,2)) as actual_price,
        p.status, 
        p.create_by, 
        p.create_at, 
        p.unit, 
        p.receive_date,
        c.name AS category_name,
        c.barcode AS category_barcode,
        (CAST(p.qty AS DECIMAL(10,2)) * CAST(p.unit_price AS DECIMAL(10,2))) AS original_price,
        CASE
          WHEN p.discount > 0 AND p.discount IS NOT NULL 
          THEN CAST(p.qty AS DECIMAL(10,2)) * CAST(p.unit_price AS DECIMAL(10,2)) * (1 - CAST(p.discount AS DECIMAL(5,2)) / 100)
          ELSE CAST(p.qty AS DECIMAL(10,2)) * CAST(p.unit_price AS DECIMAL(10,2))
        END AS total_price
      FROM product p
      LEFT JOIN category c ON p.category_id = c.id
      INNER JOIN user u ON p.user_id = u.id
      INNER JOIN user cu ON cu.group_id = u.group_id
      WHERE p.customer_id = ? AND cu.id = ?
      ${user_id ? 'AND p.user_id = ?' : ''}
      AND p.status != 'deleted'
      ORDER BY p.create_at DESC
    `;

    const sqlParams = user_id ? [customer_id, req.current_id, user_id] : [customer_id, req.current_id];

    // Execute queries
    const [categoryProducts] = await db.query(sqlCustomerProducts, sqlParams);
    const [detailedProducts] = await db.query(sqlDetailedProducts, sqlParams);

    // Calculate summary with proper null handling
    const summary = {
      total_categories: categoryProducts.length,
      total_products: detailedProducts.length,
      total_quantity: categoryProducts.reduce((sum, item) => {
        const qty = parseFloat(item.total_quantity) || 0;
        return sum + qty;
      }, 0),
      total_value: categoryProducts.reduce((sum, item) => {
        const value = parseFloat(item.total_value) || 0;
        return sum + value;
      }, 0),
      avg_unit_price: categoryProducts.length > 0
        ? categoryProducts.reduce((sum, item) => {
          const price = parseFloat(item.avg_unit_price) || 0;
          return sum + price;
        }, 0) / categoryProducts.length
        : 0
    };

    // Format the response data
    const formattedCategories = categoryProducts.map(category => ({
      ...category,
      total_quantity: parseFloat(category.total_quantity) || 0,
      total_value: parseFloat(category.total_value) || 0,
      avg_unit_price: parseFloat(category.avg_unit_price) || 0,
      product_count: parseInt(category.product_count) || 0
    }));

    const formattedProducts = detailedProducts
      .filter(product => parseFloat(product.qty) > 0) // ✅ Filter Here
      .map(product => ({
        ...product,
        qty: parseFloat(product.qty) || 0,
        unit_price: parseFloat(product.unit_price) || 0,
        discount: parseFloat(product.discount) || 0,
        actual_price: parseFloat(product.actual_price) || 0,
        original_price: parseFloat(product.original_price) || 0,
        total_price: parseFloat(product.total_price) || 0
      }));

    return res.json({
      error: false,
      data: {
        customer: customerInfo[0],
        summary: {
          ...summary,
          total_quantity: Math.round(summary.total_quantity * 100) / 100,
          total_value: Math.round(summary.total_value * 100) / 100,
          avg_unit_price: Math.round(summary.avg_unit_price * 100) / 100
        },
        categories: formattedCategories,
        products: formattedProducts
      }
    });

  } catch (error) {
    console.error("Error while updating product:", error);
    logError("product.getCustomerProducts", error, res);
   
  }
};
exports.create = async (req, res) => {
  try {
    const {
      user_id, name, category_id, company_name, description, qty,
      actual_price, unit, unit_price, discount, status, create_at, receive_date,
      customer_id
    } = req.body;



    if (!user_id || !name || !category_id || !qty || !unit_price || !customer_id) {
      return res.status(400).json({
        error: true,
        message: "Missing required fields (user_id, name, category_id, qty, unit_price, customer_id).",
      });
    }

    const [categoryRow] = await db.query(
      "SELECT barcode, name FROM category WHERE id = :category_id",
      { category_id }
    );

    if (!categoryRow || categoryRow.length === 0) {
      return res.status(400).json({
        error: true,
        message: "Invalid category_id, category not found.",
      });
    }

    const resolvedActualPrice = actual_price || 1190;
    const resolvedCustomerId = customer_id;

    const checkSql = `
      SELECT * FROM product 
      WHERE customer_id = :customer_id AND category_id = :category_id AND name = :name AND user_id = :user_id
      LIMIT 1
    `;
    const [existingProducts] = await db.query(checkSql, {
      customer_id: resolvedCustomerId,
      category_id,
      name,
      user_id
    });

    let productId;
    let isNewProduct = false;

    if (existingProducts.length > 0) {
      // ✅ Update existing product qty (sum it)
      const existingProduct = existingProducts[0];
      const newQty = parseInt(existingProduct.qty) + parseInt(qty);

      const updateSql = `
        UPDATE product 
        SET qty = :new_qty, unit_price = :unit_price, discount = :discount, actual_price = :actual_price, description = :description
        WHERE id = :id
      `;

      await db.query(updateSql, {
        new_qty: newQty,
        unit_price,
        discount,
        actual_price: resolvedActualPrice,
        description: description || '',
        id: existingProduct.id
      });

      productId = existingProduct.id;
    } else {
      // ✅ Generate barcode before insertion
      const barcodeQuery = `
        SELECT CONCAT('P',LPAD((SELECT COALESCE(MAX(id),0) + 1 FROM product), 3, '0')) as barcode
      `;
      const [barcodeResult] = await db.query(barcodeQuery);
      const generatedBarcode = barcodeResult[0]?.barcode || `P${Date.now()}`;

      // ✅ Insert new product WITH barcode
      const insertSql = `
        INSERT INTO product 
        (user_id, name, category_id, barcode, company_name, description, qty, actual_price, unit, unit_price, discount, status, create_by, create_at, receive_date, customer_id)
        VALUES
        (:user_id, :name, :category_id, :barcode, :company_name, :description, :qty, :actual_price, :unit, :unit_price, :discount, :status, :create_by, :create_at, :receive_date, :customer_id)
      `;

      const insertParams = {
        user_id,
        name,
        category_id,
        barcode: generatedBarcode, // ✅ ADD BARCODE HERE
        company_name,
        description,
        qty,
        actual_price: resolvedActualPrice,
        unit,
        unit_price,
        discount,
        status,
        create_by: req.auth?.name || 'system',
        create_at,
        receive_date,
        customer_id: resolvedCustomerId
      };

      const [result] = await db.query(insertSql, insertParams);
      productId = result.insertId;
      isNewProduct = true;

    }

    // ✅ Insert product detail (history record)
    if (productId) {
      const totalPrice = ((qty * unit_price) * (1 - (discount || 0) / 100)) / resolvedActualPrice;

      const detailSql = `
        INSERT INTO product_details (
          product_id, user_id, customer_id, name, description, category, company_name,
          qty, unit, unit_price, total_price, status, created_at, created_by, receive_date
        )
        VALUES (
          :product_id, :user_id, :customer_id, :name, :description, :category, :company_name,
          :qty, :unit, :unit_price, :total_price, :status, :created_at, :created_by, :receive_date
        )
      `;

      await db.query(detailSql, {
        product_id: productId,
        user_id,
        customer_id: resolvedCustomerId,
        name,
        description: description || '',
        category: category_id,
        company_name: company_name || '',
        qty,
        unit: unit || '',
        unit_price,
        total_price: totalPrice,
        status: status || 1,
        created_at: create_at || null,
        created_by: req.auth?.name || 'system',
        receive_date: receive_date || null
      });

      const [productData] = await db.query(`
        SELECT 
          p.id, p.name, p.category_id, p.barcode, p.user_id, p.company_name, 
          p.description, p.qty, p.unit_price, p.discount, p.actual_price, p.status, 
          p.create_by, p.create_at, p.unit, p.customer_id,
          c.name AS category_name,
          (p.qty * p.unit_price) AS original_price,
          CASE
            WHEN p.discount > 0 THEN ((p.qty * p.unit_price) * (1 - p.discount / 100)) / p.actual_price
            ELSE (p.qty * p.unit_price) / p.actual_price
          END AS total_price
        FROM product p  
        INNER JOIN category c ON p.category_id = c.id
        WHERE p.id = :id
      `, { id: productId });

      return res.json({
        error: false,
        message: isNewProduct ? "Product created successfully." : "Product quantity updated successfully.",
        data: productData[0]
      });
    }

    return res.status(500).json({
      error: true,
      message: "Failed to retrieve product data after creation."
    });

  } catch (error) {
    console.error("❌ Error while creating product:", error);
    return res.status(500).json({
      success: false,
      message: "An error occurred while creating the product.",
    });
  }
};

exports.update = async (req, res) => {
  try {
    // Extracting fields from request body
    const {
      id, name, category_id, company_name, description, qty, unit,
      unit_price, discount, status, actual_price, create_at, receive_date
    } = req.body;

    if (!id) {
      return res.status(400).json({
        success: false,
        message: "Product ID is required for the update.",
      });
    }

    const convertedUnitPrice = parseFloat(unit_price);
    const convertedDiscount = discount ? parseFloat(discount) : 0;
    const convertedActualPrice = parseFloat(actual_price);

    if (isNaN(convertedUnitPrice) || isNaN(convertedActualPrice)) {
      return res.status(400).json({
        success: false,
        message: "Invalid unit_price or actual_price. Please provide valid numbers.",
      });
    }

    const sql = `
      UPDATE product
      SET 
        name = :name, 
        category_id = :category_id, 
        company_name = :company_name, 
        description = :description, 
        qty = :qty, 
        unit = :unit, 
        unit_price = :unit_price, 
        discount = :discount, 
        status = :status,
        actual_price = :actual_price,
        create_at = :create_at,
        receive_date = :receive_date
      WHERE id = :id
    `;

    const [data] = await db.query(sql, {
      id,
      name,
      category_id,
      company_name,
      description,
      qty,
      unit,
      unit_price: convertedUnitPrice,
      discount: convertedDiscount,
      status,
      actual_price: convertedActualPrice,
      create_at,
      receive_date
    });

    if (data.affectedRows === 0) {
      return res.status(404).json({
        success: false,
        message: "Product not found.",
      });
    }

    res.json({
      success: true,
      message: "Product updated successfully.",
      data,
    });
  } catch (error) {
    console.error("Error while updating product:", error);
    logError("product.update", error, res);
    res.status(500).json({
      success: false,
      message: "An error occurred while updating the product. Please try again later.",
    });
  }
};





exports.remove = async (req, res) => {
  try {
    const id = req.params.id || req.body.id; // Check both params & body

    if (!id) {
      return res.status(400).json({ message: "Product ID is required!" });
    }

    var [data] = await db.query("DELETE FROM product WHERE id = :id", { id });

    if (data.affectedRows === 0) {
      return res.status(404).json({ message: "Product not found!" });
    }

    res.json({ message: "Product deleted successfully!" });
  } catch (error) {
    logError("remove.product", error, res);
  }
};

exports.newBarcode = async (req, res) => {
  try {
    var sql =
      "SELECT " +
      "CONCAT('P',LPAD((SELECT COALESCE(MAX(id),0) + 1 FROM product), 3, '0')) " +
      "as barcode";
    var [data] = await db.query(sql);
    res.json({
      barcode: data[0].barcode,
    });
  } catch (error) {
    logError("remove.create", error, res);
  }
};

isExistBarcode = async (barcode) => {
  try {
    var sql = "SELECT COUNT(id) as Total FROM product WHERE barcode=:barcode";
    var [data] = await db.query(sql, {
      barcode: barcode,
    });
    if (data.length > 0 && data[0].Total > 0) {
      return true; // ស្ទួន
    }
    return false; // អត់ស្ទួនទេ
  } catch (error) {
    logError("remove.create", error, res);
  }
};


exports.getProductDetail = async (req, res) => {
  try {
    const { txt_search, category_id, page, from_date, to_date, is_list_all } = req.query;

    const listAll = is_list_all === 'true';
    let sqlSelect = `
      SELECT 
        pd.id AS detail_id,
        p.id AS product_id,
        cu.name AS customer_name, 
        pd.name,
        pd.barcode AS detail_barcode,
        pd.company_name AS detail_company_name,
        pd.description AS detail_description,
        pd.qty,
        pd.unit,
        pd.unit_price AS detail_unit_price,
        pd.total_price,
        c.actual_price,
        c.name AS category_name,
        pd.status AS detail_status, 
        pd.created_at AS detail_created_at,
        pd.updated_at AS updated_at,  -- Use actual updated_at column
        pd.created_by AS detail_created_by,
        pd.is_completed,  -- FIXED: Added missing is_completed field
        p.create_at AS product_created_at,
        pd.receive_date AS receive_date,
        p.create_by AS product_created_by,
        u.group_id,
        u.name AS user_name
    `;
    let sqlFrom = `
      FROM product_details pd
      INNER JOIN product p ON pd.product_id = p.id
      INNER JOIN category c ON CAST(pd.category AS UNSIGNED) = c.id
      INNER JOIN customer cu ON pd.customer_id = cu.id
      INNER JOIN user u ON pd.user_id = u.id
      INNER JOIN user cu_user ON cu_user.group_id = u.group_id
    `;
    let sqlWhere = `WHERE cu_user.id = ?`;
    const params = [req.current_id];
    
    if (from_date && to_date) {
      sqlWhere += ` AND DATE(pd.created_at) >= ? AND DATE(pd.created_at) <= ?`;
      params.push(from_date, to_date);
    } else if (from_date) {
      sqlWhere += ` AND DATE(pd.created_at) >= ?`;
      params.push(from_date);
    } else if (to_date) {
      sqlWhere += ` AND DATE(pd.created_at) <= ?`;
      params.push(to_date);
    }
    
    if (txt_search) {
      const pattern = `%${txt_search}%`;
      sqlWhere += `
        AND (
          pd.name LIKE ? OR 
          pd.barcode LIKE ? OR 
          pd.company_name LIKE ? OR 
          pd.description LIKE ? OR
          c.name LIKE ? OR
          cu.name LIKE ?
        )
      `;
      params.push(pattern, pattern, pattern, pattern, pattern, pattern);
    }
    
    if (category_id) {
      sqlWhere += ` AND CAST(pd.category AS UNSIGNED) = ?`;
      params.push(category_id);
    }
    
    const countSql = `SELECT COUNT(*) AS total ${sqlFrom} ${sqlWhere}`;
    const [countRows] = await db.query(countSql, params);
    const total = countRows[0]?.total || 0;
    
    let sql = `${sqlSelect} ${sqlFrom} ${sqlWhere} ORDER BY CAST(pd.description AS UNSIGNED) ASC`;
    
    if (!listAll && page) {
      const pageSize = 10;
      const offset = (parseInt(page) - 1) * pageSize;
      sql += ` LIMIT ${pageSize} OFFSET ${offset}`;
    }
    
    const [rows] = await db.query(sql, params);
    
    const formattedRows = rows.map((item) => {
      const totalPrice =
        (parseFloat(item.qty || 0) * parseFloat(item.detail_unit_price || 0)) /
        (parseFloat(item.actual_price) || 1);
      return {
        ...item,
        corrected_total_price: totalPrice.toFixed(2),
        is_completed: Boolean(item.is_completed) // Now this will work since field is included
      };
    });

    res.json({
      success: true,
      data: formattedRows,
      total,
      message: formattedRows.length === 0 ? "No product details found" : undefined,
    });
  } catch (error) {
    console.error("Error while getting product details:", error);
    logError("product.details", error, res);
    res.status(500).json({
      success: false,
      message: "An error occurred while retrieving product details. Please try again later.",
    });
  }
};
exports.updateProductCompletion = async (req, res) => {
  try {
    const { detail_id, is_completed } = req.body;

    if (!detail_id) {
      return res.status(400).json({
        success: false,
        message: "Product detail ID is required"
      });
    }

    const sql = `
      UPDATE product_details  
      SET is_completed = ?, updated_at = NOW() 
      WHERE id = ?
    `;

    const [result] = await db.query(sql, [is_completed ? 1 : 0, detail_id]);
 
    if (result.affectedRows === 0) {
      return res.status(404).json({
        success: false,
        message: "Product detail not found"
      });
    }

    res.json({
      success: true,
      message: "Completion status updated successfully"
    });

  } catch (error) {
   logError("updateProductCompletion",error)
  }
};





exports.getListByCurrentUserGroup = async (req, res) => {
  try {
    var sql = `
      SELECT 
        p.id, 
        p.name, 
        p.category_id, 
        p.barcode, 
        p.company_name,
        p.description, 
        p.qty, 
        p.unit_price, 
        p.discount, 
        p.actual_price, 
        p.status,
        p.create_by, 
        p.create_at, 
        p.unit, 
        p.customer_id,
        c.name AS category_name,
        c.barcode AS category_barcode,
        cu.name AS customer_name,
        cu.address AS customer_address,
        cu.tel AS customer_tel,
        c.actual_price AS category_actual_price,
        (p.qty * p.unit_price) AS original_price,
        CASE
          WHEN p.discount > 0 THEN ((p.qty * p.unit_price) * (1 - p.discount / 100)) / c.actual_price
          ELSE (p.qty * p.unit_price) / c.actual_price
        END AS total_price,
        u.group_id,
        u.name AS created_by_name,
        u.username AS created_by_username
      FROM product p
      LEFT JOIN category c ON p.category_id = c.id
      LEFT JOIN customer cu ON p.customer_id = cu.id
      INNER JOIN user u ON p.user_id = u.id
      WHERE u.group_id = (SELECT group_id FROM user WHERE id = :current_user_id)
        AND p.qty > 0
      ORDER BY p.customer_id, p.id DESC
    `;

    var [data] = await db.query(sql, {
      current_user_id: req.current_id // មកពី token validation
    });

    res.json({
      list: data,
      message: "Success!",
    });
  } catch (error) {
    logError("product.getListByCurrentUserGroup", error, res);
  }
};